# GraphRAG 生产环境最佳实践 FAQ

本文档整理了在生产环境中部署和使用 GraphRAG 时常见的高级问题及其最佳实践，特别针对 Google Cloud Platform (GCP) 和 Gemini 模型进行了优化建议。

## 1. GraphRAG 与 AI Agent 的集成

**Q: 在生产环境下，将 GraphRAG 的查询结果作为 Agent 上下文的一部分可行吗？适合什么场景？**

**A:** 完全可行，这是构建高级“领域专家”Agent 的核心模式之一。GraphRAG 提供的不是零散的文档片段，而是结构化的知识摘要和关系网络，能为 Agent 提供高层级的认知地图。

**适合场景：**
*   **复杂主题研究**：需要综合数百份文档才能回答的宏观问题（如“分析中东局势对油价的综合影响”）。Agent 可利用 **Global Search** 获得宏观摘要。
*   **实体深度调查**：需要挖掘隐藏关联的风控或情报分析（如“调查 A 公司的潜在风险关联”）。Agent 可利用 **Local Search** 获取多跳关系网络。
*   **长期记忆注入**：将特定领域的社区摘要作为 Agent 的 System Prompt，使其“天生”具备领域全局观。

---

## 2. 生产环境中的知识更新与纠错

**Q: 生产环境中主要面临知识持续积累，且存在“昨天正确、今天错误”的情况。如何保证索引的实时性和正确性？**

**A:** 这是一个复杂挑战。GraphRAG 的图谱结构使得单纯“删除”旧知识非常困难。

**推荐策略 (Lambda 架构)：**
1.  **短期（增量索引）**：利用 GraphRAG 的增量能力快速摄入新文档。对于冲突信息，新知识会与旧知识共存。
2.  **中期（定期全量重建）**：这是清除累积错误和“图谱噪音”最可靠的方法。建议每周或每月在一个新的 Spanner 表前缀中运行一次全量索引，完成后无缝切换服务。
3.  **长期（时间感知）**：在源文档层面引入 `valid_from`/`valid_to` 时间戳，让上层 Agent 在检索时能区分当前有效的知识。

---

## 3. 文档变更的处理机制

**Q: 如果我在 input 目录中修改了同一个文档的内容，GraphRAG 会自动更新它之前的索引吗？**

**A:** **不会自动“更新”**。
*   **机制**：GraphRAG 使用内容哈希识别文档。内容变更后，它会被视为一个**全新的文档**。
*   **后果**：新旧信息会同时存在于图谱中，可能导致信息冲突、冗余和社区结构失真（图谱污染）。
*   **最佳实践**：遵循**文档不可变原则**。如果文档需要更新，请发布新版本（如 `policy_v2.txt`）并删除旧版本（`policy_v1.txt`），然后等待下一次全量重建来彻底清洗图谱。

---

## 4. 针对 Gemini 模型的特定优化

**Q: 对于特定的 Gemini 模型（如 Gemini 1.5 Pro/Flash），GraphRAG 还有优化的空间吗？**

**A:** 有巨大的优化空间。默认配置是为短上下文模型设计的，浪费了 Gemini 的长上下文能力。

**核心优化策略：**
1.  **大幅增加 Chunk Size**：将 `settings.yaml` 中的 `chunks.size` 从默认的 1200 提升到 **32k** 甚至更大。Gemini 能一次性理解长文档，提取出更完整、跨段落的复杂关系，同时显著减少 API 调用次数。
2.  **撑爆上下文窗口**：大幅增加搜索时的 `max_context_tokens`（如提升到 **200k+**）。让 Agent 在回答复杂问题时能同时参考海量的社区摘要和实体信息。
3.  **利用原生结构化输出**：确保底层调用 Vertex AI 时启用了 Gemini 原生的 JSON 输出模式，提高图谱提取的稳定性。

---

## 5. Spanner 生产环境性能优化

**Q: 针对 Spanner 的生产级部署，在性能上还有哪些具体的优化点？**

**A:** 目前的实现功能完备且稳定，但在大规模数据（千万级以上）场景下，仍有以下关键优化空间：

1.  **并行异步写入 (High Impact)**：
    *   *现状*：当前使用串行分批写入（500行/批）。
    *   *优化*：利用 `asyncio` 同时发起多个写入请求，充分利用 Spanner 的高并发能力，显著缩短全量索引时间。

2.  **分区读取 (Partitioned Reads) (High Impact)**：
    *   *现状*：全量加载表时使用单一的 `SELECT *`。
    *   *优化*：对于超大表，使用 Spanner 的 Partitioned Reads 将大查询切分为多个并行子查询，避免单点瓶颈和超时。

3.  **利用 Data Boost (Medium Impact)**：
    *   *优化*：在运行大规模离线分析任务时使用 Spanner Data Boost，利用无服务器资源进行计算，实现与在线事务工作负载的完全隔离。

4.  **向量索引精细化调优 (Medium Impact)**：
    *   *优化*：根据具体数据规模调整 IVF 索引参数（如 `num_partitions`, `num_neighbors`）以平衡搜索精度和延迟。

5.  **Schema 优化 (Interleaved Tables) (Advanced)**：
    *   *优化*：如果访问模式固定（如总是同时读取文档及其 TextUnits），可使用 Interleaved Tables 将子表数据物理存储在父表行内以减少 IO。